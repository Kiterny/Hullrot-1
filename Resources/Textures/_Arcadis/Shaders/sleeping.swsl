uniform highp float effectScale;
const highp float closeRate = 1.2; // >1.0 = faster close, <1.0 = slower close

const highp float TimeScale = 0.15;
const highp float NoiseScale = 4.0; // scale of the noise

highp float noise(highp vec2 p) {
    const highp float K1 = 0.366025404;
    const highp float K2 = 0.211324865;

    highp vec2  i = floor(p + (p.x+p.y)*K1);
    highp vec2  a = p - i + (i.x+i.y)*K2;
    highp float m = step(a.y,a.x);
    highp vec2  o = vec2(m,1.0-m);
    highp vec2  b = a - o + K2;
    highp vec2  c = a - 1.0 + 2.0*K2;
    highp vec3  h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
    highp vec3  n = h*h*h*h *
        vec3(dot(a,zRandom(i+0.0)),
             dot(b,zRandom(i+o)),
             dot(c,zRandom(i+1.0)));
    return dot(n, vec3(70.0));
}

highp float mixNoise(highp vec2 point, highp float phase) {
    highp float time = TIME * TimeScale + phase;
    highp float a = noise(NoiseScale * point - time);
    highp float b = noise(NoiseScale * point + time);
    return mix(a,b,0.5);
}

void fragment() {
    highp vec2 uv = FRAGCOORD.xy * SCREEN_PIXEL_SIZE.xy;
    highp vec2 center = vec2(0.5, 0.5);
    highp float dist = length(uv - center);

    highp float t = clamp(effectScale * closeRate, 0.0, 1.0);
    highp float r1 = 0.7 * (1.0 - t);
    highp float r2 = 1.0 * (1.0 - t);

    // --- smooth fades ---
    const highp float fadeWidth = 0.05;

    // fade inner → noisy ring
    highp float fade1 = smoothstep(r1 - fadeWidth, r1 + fadeWidth, dist);

    // fade noisy ring → outer solid
    highp float fade2 = smoothstep(r2 - fadeWidth, r2 + fadeWidth, dist);

    // noisy alpha
    highp float noiseOut = mixNoise(uv, 1);
    noiseOut = noiseOut * 0.5 + 0.5;
    noiseOut = clamp(noiseOut * 1.5, 0.0, 1.0);

    // blend alpha in two stages
    highp float alpha = mix(0.0, noiseOut, fade1);
    alpha = mix(alpha, 1.0, fade2);

    COLOR = vec4(0.0, 0.0, 0.0, alpha);
}
